---
title: Android | PCM to WAV
date: 2023-12-13
description: Androidì—ì„œ AudioRecord APIë¥¼ í™œìš©í•œ wav ë…¹ìŒí•˜ê¸°
---

# 1. PCMê³¼ WAVëŠ” ë¬´ì—‡ì¸ê°€?

## 1. PCM

**pcm (Pulse Code Modulation) íŒŒì¼ì€**Â ì•„ë‚ ë¡œê·¸ ì‹ í˜¸ë¥¼ ë””ì§€í„¸ ì‹ í˜¸ë¡œ ë³€í™˜í•˜ëŠ” ë°©ì‹ ì¤‘ í•˜ë‚˜ë¥¼ ì˜ë¯¸í•œë‹¤. pcmì€ ì••ì¶•ë˜ì§€ ì•Šì€ ì›ì‹œ ì˜¤ë””ì˜¤ ë°ì´í„°ë¥¼ ë‚˜íƒ€ë‚´ê¸° ìœ„í•´ ì£¼ë¡œ ì‚¬ìš©ë˜ê³  â€œ.pcmâ€ , â€œ.rawâ€ ë“±ì˜ í™•ì¥ìë¡œ ì‚¬ìš©ë  ìˆ˜ ìˆë‹¤.

## 2. WAV

WAVíŒŒì¼ì€ PCM ë°ì´í„°ì— í—¤ë”ì™€ ë©”íƒ€ë°ì´í„°ê°€ ì¶”ê°€ëœ ì˜¤ë””ì˜¤ ë°ì´í„° ì €ì¥ í˜•ì‹ì´ë‹¤.

**WAVíŒŒì¼ í—¤ë”**ì—ëŠ” ì˜¤ë””ì˜¤ ë°ì´í„°ì˜ í˜•ì‹, ì±„ë„ìˆ˜, ìƒ˜í”Œë§ ì†ë„ ë¹„íŠ¸ ë‹¹ ìƒ˜í”Œ ìˆ˜ ë“±ê³¼ ê°™ì€ ì˜¤ë””ì˜¤ ìƒ˜í”Œì— ê´€í•œ ì •ë³´ê°€ ë“¤ì–´ê°€ìˆë‹¤.

**ë©”íƒ€ë°ì´í„°**ì—ëŠ” ê³¡ì˜ ì œëª©, ì•„í‹°ìŠ¤íŠ¸ ì •ë³´ë“± ì‚¬ìš©ìê°€ ì›í•˜ëŠ” ì •ë³´ë¥¼ í¬í•¨ í•  ìˆ˜ ìˆë‹¤. â€‹ â€‹

# 2. WAV ë§Œë“¤ê¸°

## 1. WAVí—¤ë”êµ¬ì¡°

waví—¤ë”ì— ëŒ€í•´ì„œ ì•Œì•„ì•¼ wavíŒŒì¼ì„ ë§Œë“¤ ìˆ˜ ìˆë‹¤.

WAVí—¤ë”ëŠ” íŒŒì¼ ì‹œì‘ ë¶€ë¶„ì— ìœ„ì¹˜í•´ íŒŒì¼ì— ëŒ€í•œ ê¸°ë³¸ì ì¸ ì •ë³´ë“¤ì„ ê°€ì§€ê³  ìˆë‹¤.

ì´ 44ë°”ì´íŠ¸ë¡œ ì´ë£¨ì–´ì ¸ ìˆìœ¼ë©° ì•„ë˜ì™€ ê°™ì€ í•„ë“œë¡œ êµ¬ì„±ë˜ì–´ ìˆë‹¤. â€‹

1. **Chunk ID (4ë°”ì´íŠ¸)**

   íŒŒì¼ì´ RIFF í˜•ì‹ì„ì„ ë‚˜íƒ€ë‚´ê¸° ìœ„í•´ â€œRIFFâ€ 4ê¸€ì ASCII ë¬¸ìì—´

2. **File Size (4ë°”ì´íŠ¸)**

   íŒŒì¼ ì „ì²´ì— ëŒ€í•œ Sizeë¥¼ ë‚˜íƒ€ë‚¸ë‹¤. ë‹¨ **Chunk ID ê°’ê³¼ File Size ê°’ì„ ì œì™¸**í•œ ê°’ì´ê¸° ë•Œë¬¸ì— **ì „ì²´ íŒŒì¼í¬ê¸° - 8 byteê°€** ëœë‹¤.

   ë¦¬í‹€ ì—”ë””ì•ˆ(littleÂ endian)ê°’ìœ¼ë¡œ ì €ì¥í•œë‹¤

3. **Format (4ë°”ì´íŠ¸)**

   â€œWAVEâ€ 4ê¸€ì ASCII ë¬¸ìì—´ì´ ë“¤ì–´ê°„ë‹¤.

4. **Subchunk1 ID (4 ë°”ì´íŠ¸)**

   "**fmt** "ë¼ëŠ” 4ê¸€ì ASCII ë¬¸ìì—´ì´ ë“¤ì–´ê°„ë‹¤ **(fmt + ê³µë°±)**

5. **Subchunk1 Size (4 ë°”ì´íŠ¸):**

   í—¤ë”ì˜ ì²« ë²ˆì§¸ ì„œë¸Œì²´ì´í¬ í¬ê¸°ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. ì¼ë°˜ì ìœ¼ë¡œ 16ë°”ì´íŠ¸ ê³ ì •

6. **Audio Format (2 ë°”ì´íŠ¸):**

   ì˜¤ë””ì˜¤ ë°ì´í„°ì˜ í¬ë§·ì„ ë‚˜íƒ€ë‚¸ë‹¤.

   PCMì˜ ê²½ìš° 1ë¡œ ì„¤ì •ë˜ëŠ”ë° ëŒ€ë¶€ë¶„ì˜ wavíŒŒì¼ì€ PCMì´ê¸° ë•Œë¬¸ì— 1 ê³ ì •ê°’ ì²˜ëŸ¼ ì“°ì¸ë‹¤.

7. **Num Channels (2 ë°”ì´íŠ¸):**

   ì˜¤ë””ì˜¤ ì±„ë„ì˜ ìˆ˜ë¥¼ ë‚˜íƒ€ë‚¸ë‹¤.

   ëª¨ë…¸ 1 , ìŠ¤íŠ¸ë ˆì˜¤ 2 â€¦

8. **Sample Rate (4 ë°”ì´íŠ¸):**

   ìƒ˜í”Œë§ ì†ë„ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.

   ë¦¬í‹€ ì—”ë””ì•ˆ(littleÂ endian

9. **Byte Rate (4 ë°”ì´íŠ¸):**

   ì´ˆë‹¹ ë°”ì´íŠ¸ ìˆ˜

   ë¦¬í‹€ ì—”ë””ì•ˆ(littleÂ endian)

10. **Block Align (2 ë°”ì´íŠ¸):**

    ë¸”ë¡ì˜ í¬ê¸°ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. ì±„ë„ ìˆ˜ì™€ ë¹„íŠ¸ ë‹¹ ìƒ˜í”Œ ìˆ˜ì— ë”°ë¼ ê²°ì •ë©ë‹ˆë‹¤.

11. **Bits Per Sample (2 ë°”ì´íŠ¸):**

    ë¹„ë“œ ëìŠ¤ë¥¼ ì˜ë¯¸í•œë‹¤.

12. **Subchunk2 ID (4 ë°”ì´íŠ¸):**

    "data"ë¼ëŠ” 4ê¸€ìë¡œ ì´ë£¨ì–´ì§„ ASCII ë¬¸ìì—´ì„ ì“´ë‹¤.

13. **Subchunk2 Size (4 ë°”ì´íŠ¸):**

    ì˜¤ë””ì˜¤ ë°ì´í„°ì˜ í¬ê¸°ë¥¼ ë‚˜íƒ€ë‚¸ë‹¤. ì¦‰ **ì „ì²´íŒŒì¼ - headerí¬ê¸°**

    ë¦¬í‹€ ì—”ë””ì•ˆ(littleÂ endian)

â€‹

> ğŸ’¡ **ë¦¬í‹€ ì—”ë””ì•ˆì´ë€?** ë¦¬í‹€ ì—”ë””ì•ˆì€ ê°€ì¥ ë‚®ì€ ì£¼ì†Œì— ì‘ì€ ë‹¨ìœ„ì˜ ë°”ì´íŠ¸ê°€ ì €ì¥ë˜ëŠ” ë°©ì‹ â€‹ **ì˜ˆì‹œ** 16ì§„ìˆ˜ 0x12345678ì„ ë©”ëª¨ë¦¬ì— ì €ì¥ [0x78 , 0x56 , 0x34 , 0x12]

â€‹ â€‹

# 3. ì½”ë“œ ì˜ˆì‹œ(Kotlin)

ì•ˆë“œë¡œì´ë“œì—ì„œ **AudioRecord API**ë¥¼ í™œìš©í•´ ì¶”ì¶œí•œ PCMíŒŒì¼ì„ WAVë¡œ ë³€í™˜í•˜ê¸°

```kotlin
private var sampleRateInHz = 16000
private var audioChannel = AudioFormat.CHANNEL_IN_MONO
private var audioFormat = AudioFormat.ENCODING_PCM_16BIT

bufferSize = AudioRecord.getMinBufferSize(sampleRateInHz, channelConfig, audioFormat)

private fun addWavHeader(out: FileOutputStream, totalAudioLen: Long, totalDataLen: Long) {
        val sampleRate = sampleRateInHz.toLong()
        val channels = if (channelConfig == AudioFormat.CHANNEL_IN_MONO) 1 else 2
        val bitsPerSample = if (audioFormat == AudioFormat.ENCODING_PCM_8BIT) 8 else 16
        val byteRate = sampleRate * channels * bitsPerSample / 8
        val blockAlign = channels * bitsPerSample / 8
        val header = ByteArray(44)

        header[0] = 'R'.code.toByte() // 1.RIFF
        header[1] = 'I'.code.toByte()
        header[2] = 'F'.code.toByte()
        header[3] = 'F'.code.toByte()
        header[4] = (totalDataLen and 0xffL).toByte() // 2.íŒŒì¼ ì‚¬ì´ì¦ˆ í¬ê¸°
        header[5] = (totalDataLen shr 8 and 0xffL).toByte()
        header[6] = (totalDataLen shr 16 and 0xffL).toByte()
        header[7] = (totalDataLen shr 24 and 0xffL).toByte()
        header[8] = 'W'.code.toByte() // 3.WAVE
        header[9] = 'A'.code.toByte()
        header[10] = 'V'.code.toByte()
        header[11] = 'E'.code.toByte()
        header[12] = 'f'.code.toByte() // 4.'fmt '
        header[13] = 'm'.code.toByte()
        header[14] = 't'.code.toByte()
        header[15] = ' '.code.toByte()
        header[16] = 16 // 5.16ê³ ì •
        header[17] = 0
        header[18] = 0
        header[19] = 0
        header[20] = 1 // 6.format = PCM = 1
        header[21] = 0
        header[22] = channels.toByte() // 7.ì±„ë„ìˆ˜
        header[23] = 0
        header[24] = (sampleRate and 0xffL).toByte() // 8.ìƒ˜í”Œë ˆì´íŠ¸
        header[25] = (sampleRate shr 8 and 0xffL).toByte()
        header[26] = (sampleRate shr 16 and 0xffL).toByte()
        header[27] = (sampleRate shr 24 and 0xffL).toByte()
        header[28] = (byteRate and 0xffL).toByte() // 9.ë°”ì´íŠ¸ ë ˆì´íŠ¸
        header[29] = (byteRate shr 8 and 0xffL).toByte()
        header[30] = (byteRate shr 16 and 0xffL).toByte()
        header[31] = (byteRate shr 24 and 0xffL).toByte()
        header[32] = blockAlign.toByte() // 10.ë¸”ë¡í¬ê¸°
        header[33] = 0
        header[34] = bitsPerSample.toByte() // 11.ë¹„íŠ¸ ëìŠ¤
        header[35] = 0
        header[36] = 'd'.code.toByte() // 12.'data'
        header[37] = 'a'.code.toByte()
        header[38] = 't'.code.toByte()
        header[39] = 'a'.code.toByte()
        header[40] = (totalAudioLen and 0xffL).toByte() // 13.ì „ì²´ íŒŒì¼ - headr = pcmí¬ê¸° (ë©”íƒ€ë°ì´í„° ì—†ìŒ)
        header[41] = (totalAudioLen shr 8 and 0xffL).toByte()
        header[42] = (totalAudioLen shr 16 and 0xffL).toByte()
        header[43] = (totalAudioLen shr 24 and 0xffL).toByte()
        out.write(header, 0, 44)
}

val out = FileOutputStream(wavíŒŒì¼ê²½ë¡œ)
val in = FileInputStream(pcmíŒŒì¼ê²½ë¡œ)
val totalAudioLen: Long = in.getChannel().size() // ì˜¤ë””ì˜¤ íŒŒì¼ ì‚¬ì´ì¦ˆ
val totalDataLen = totalAudioLen + 36 // í—¤ë”í¬ê¸° ë”í•˜ê¸° (1,2 í•„ë“œ ì œì™¸)

addWavHeader(out, totalAudioLen, totalDataLen)

val data = ByteArray(bufferSize)
var bytesRead: Int
//pcmíŒŒì¼ wavì— ì“°ê¸°
while (in.read(data).also { bytesRead = it } != -1) {
      out.write(data, 0, bytesRead)
}
in.close()
out.close()

```

â€‹ **ì°¸ì¡°**

https://anythingcafe.tistory.com/2 https://crystalcube.co.kr/123 https://gdnn.tistory.com/277
